use crate::color::types::{ColorGrading, Curves, ToneCurve};

// Function generated by AI
pub fn add_dither(value: f32, strength: f32) -> f32 {
    // Use a simple hash of the value to create pseudo-random noise.
    let noise = (((value * 12.9898).sin() * 43758.5453).fract() - 0.5) * strength;
    (value + noise).clamp(0.0, 1.0)
}

pub fn apply_gamma(value: f32, gamma: f32) -> f32 {
    value.powf(1.0 / gamma)
}

pub fn apply_curve(x: f32, strength: f32, curves: &Curves, tone_curve: &ToneCurve) -> f32 {
    /*
     * Normalize input
     *
     * So we will work with defined range of input
     */
    let x = x.clamp(0.0, 1.0);

    /*
     * Apply black and white point normalization
     *
     * Stretches or compresses the tonal range to fit between the black point and white point
     * black_point is where true black should start; Values below black_point get mapped to 0
     * white_point is where true white should start; Values above white_point get mapped to 1
     * tone_curve.white_point - tone_curve.black_point calculates the new range
     */
    let x = (x - tone_curve.black_point) / (tone_curve.white_point - tone_curve.black_point);

    let y = if x < curves.toe_threshold {
        // Toe region - very dark shadows
        let normalized = x / curves.toe_threshold;
        let curved = 1.0 / (1.0 + (-normalized * curves.toe_strength).exp());
        curved * curves.toe_threshold
    } else if x < curves.shadow_threshold {
        // Shadow region
        let normalized =
            (x - curves.toe_threshold) / (curves.shadow_threshold - curves.toe_threshold);
        let shadow_adjusted = normalized * curves.shadow_strength;
        curves.toe_threshold + shadow_adjusted * (curves.shadow_threshold - curves.toe_threshold)
    } else if x < curves.highlight_threshold {
        // Midtone region
        let normalized =
            (x - curves.shadow_threshold) / (curves.highlight_threshold - curves.shadow_threshold);
        let contrasted = ((normalized - 0.5) * tone_curve.contrast) + 0.5;
        curves.shadow_threshold
            + contrasted * (curves.highlight_threshold - curves.shadow_threshold)
    } else if x < curves.shoulder_threshold {
        // Highlight region
        let normalized = (x - curves.highlight_threshold)
            / (curves.shoulder_threshold - curves.highlight_threshold);
        let highlight_adjusted = 1.0 - ((1.0 - normalized) * curves.highlight_strength);
        curves.highlight_threshold
            + highlight_adjusted * (curves.shoulder_threshold - curves.highlight_threshold)
    } else {
        // Shoulder region - extreme highlights
        x
        // let normalized = (x - curves.shoulder_threshold) / (1.0 - curves.shoulder_threshold);
        // let curved = 1.0 / (1.0 + (-normalized * curves.shoulder_strength).exp());
        // curves.shoulder_threshold + curved * (1.0 - curves.shoulder_threshold)
    };

    // Final blend
    let y = y.clamp(0.0, 1.0);
    x + (y - x) * strength
}

pub fn apply_color_grading(
    r: f32,
    g: f32,
    b: f32,
    strength: f32,
    color_grading: &ColorGrading,
) -> (f32, f32, f32) {
    let luminance = 0.299 * r + 0.587 * g + 0.114 * b;

    // Apply temperature
    let red_t = r * color_grading.temperature; // Red
    let blue_t = b / color_grading.temperature; // Blue

    // Apply tint
    let tint = g * color_grading.tint; // Green

    // Apply saturation
    let r_sat = luminance + (red_t - luminance) * color_grading.saturation;
    let g_sat = luminance + (tint - luminance) * color_grading.saturation;
    let b_sat = luminance + (blue_t - luminance) * color_grading.saturation;

    // Calculate saturation factors for vibrance
    let red_sat_factor = 1.0 - ((red_t - 0.5).abs() * 2.0);
    let green_sat_factor = 1.0 - ((tint - 0.5).abs() * 2.0);
    let blue_sat_factor = 1.0 - ((blue_t - 0.5).abs() * 2.0);

    // Apply vibrance with strength blending
    let r_final = r
        + ((luminance
            + (r_sat - luminance) * (1.0 + (color_grading.vibrance - 1.0) * red_sat_factor))
            - r)
            * strength;
    let g_final = g
        + ((luminance
            + (g_sat - luminance) * (1.0 + (color_grading.vibrance - 1.0) * green_sat_factor))
            - g)
            * strength;
    let b_final = b
        + ((luminance
            + (b_sat - luminance) * (1.0 + (color_grading.vibrance - 1.0) * blue_sat_factor))
            - b)
            * strength;

    (
        r_final.max(0.0).min(1.0),
        g_final.max(0.0).min(1.0),
        b_final.max(0.0).min(1.0),
    )
}
